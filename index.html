<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Image RGB 3D Visualizer</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        #image-preview { max-width: 400px; max-height: 400px; display: block; margin-bottom: 20px; }
        #plot { width: 600px; height: 600px; }
    </style>
</head>
<body>
    <h2>Upload an Image</h2>
    <input type="file" id="image-upload" accept="image/*">
    <br><br>
    <div style="display: flex; flex-direction: row; justify-content: center; align-items: flex-start; gap: 40px; margin-bottom: 20px;">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <img id="image-preview" src="" alt="Image Preview" style="display:none; max-width:400px; max-height:400px; margin-bottom: 10px;">
            <span id="orig-label" style="display:none;">Original Image</span>
        </div>
        <div style="display: flex; flex-direction: column; align-items: center;">
            <canvas id="clustered-canvas" style="display:none;"></canvas>
            <img id="clustered-image" style="display:none;max-width:400px;max-height:400px; margin-bottom: 10px;">
            <span id="cluster-label" style="display:none;">Clustered Image</span>
        </div>
    </div>
    <div style="display: flex; flex-direction: column; align-items: center;">
        <label for="k-select">Number of Clusters (K):</label>
        <select id="k-select" style="margin-bottom: 10px;">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
        </select>
        <button id="cluster-btn" style="margin-bottom: 20px;">Cluster & Generate Image</button>
        <div id="plot"></div>
    </div>
    <canvas id="hidden-canvas" style="display:none;"></canvas>
    <script>
        const upload = document.getElementById('image-upload');
        const preview = document.getElementById('image-preview');
        const canvas = document.getElementById('hidden-canvas');
        const plotDiv = document.getElementById('plot');
    const kSelect = document.getElementById('k-select');
    const clusterBtn = document.getElementById('cluster-btn');
    const clusteredCanvas = document.getElementById('clustered-canvas');
    const clusteredImage = document.getElementById('clustered-image');

        upload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(ev) {
                preview.src = ev.target.result;
                preview.style.display = 'block';
                document.getElementById('orig-label').style.display = 'block';

                preview.onload = function() {
                    canvas.width = preview.naturalWidth;
                    canvas.height = preview.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(preview, 0, 0);

                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    const r = [], g = [], b = [], colors = [];
            const points = [];

                    // Display even more points by increasing targetPoints and marker size
                    const targetPoints = 50000; // Increased for more points
                    const totalPixels = canvas.width * canvas.height;
                    const step = Math.max(1, Math.floor(Math.sqrt(totalPixels / targetPoints)));

                    for (let y = 0; y < canvas.height; y += step) {
                        for (let x = 0; x < canvas.width; x += step) {
                            const idx = (y * canvas.width + x) * 4;
                            const red = imgData[idx];
                            const green = imgData[idx + 1];
                            const blue = imgData[idx + 2];
                            r.push(red);
                            g.push(green);
                            b.push(blue);
                points.push([red, green, blue, x, y]);

                            // Use the actual pixel color for each point
                            colors.push(`rgb(${red},${green},${blue})`);
                        }
                    }

                    const trace = {
                        x: r,
                        y: g,
                        z: b,
                        mode: 'markers',
                        type: 'scatter3d',
                        marker: {
                            size: 2, // Slightly smaller for more points
                            color: colors,
                        }
                    };
                    const layout = {
                        scene: {
                            xaxis: { title: 'Red', range: [0,255] },
                            yaxis: { title: 'Green', range: [0,255] },
                            zaxis: { title: 'Blue', range: [0,255] }
                        },
                        margin: { l:0, r:0, b:0, t:0 }
                    };
                    Plotly.newPlot(plotDiv, [trace], layout, {responsive: true});
                    // Store for clustering
                    window._rgb_points = points;
                    window._imgData = imgData;
                    window._canvasWidth = canvas.width;
                    window._canvasHeight = canvas.height;
                };
            };
            reader.readAsDataURL(file);
        });

        // Optimized K-means clustering implementation
        function kmeans(points, k, maxIter=20) {
            // points: [r,g,b,x,y]
            // Use Float32Array for centroids
            let centroids = [];
            const usedIdx = new Set();
            while (centroids.length < k) {
                const idx = Math.floor(Math.random() * points.length);
                if (!usedIdx.has(idx)) {
                    centroids.push([points[idx][0], points[idx][1], points[idx][2]]);
                    usedIdx.add(idx);
                }
            }
            let assignments = new Uint8Array(points.length);
            let changed = true;
            for (let iter = 0; iter < maxIter && changed; iter++) {
                changed = false;
                // Assign points
                for (let i = 0; i < points.length; i++) {
                    let minDist = Infinity, minIdx = 0;
                    for (let j = 0; j < k; j++) {
                        const d =
                            (points[i][0]-centroids[j][0])**2 +
                            (points[i][1]-centroids[j][1])**2 +
                            (points[i][2]-centroids[j][2])**2;
                        if (d < minDist) { minDist = d; minIdx = j; }
                    }
                    if (assignments[i] !== minIdx) changed = true;
                    assignments[i] = minIdx;
                }
                // Update centroids
                let sums = Array(k).fill(0).map(()=>[0,0,0]);
                let counts = new Uint32Array(k);
                for (let i = 0; i < points.length; i++) {
                    const c = assignments[i];
                    sums[c][0] += points[i][0];
                    sums[c][1] += points[i][1];
                    sums[c][2] += points[i][2];
                    counts[c]++;
                }
                for (let j = 0; j < k; j++) {
                    if (counts[j] > 0) {
                        centroids[j][0] = sums[j][0]/counts[j];
                        centroids[j][1] = sums[j][1]/counts[j];
                        centroids[j][2] = sums[j][2]/counts[j];
                    }
                }
            }
            return {centroids, assignments};
        }

        clusterBtn.addEventListener('click', function() {
            const k = parseInt(kSelect.value);
            const points = window._rgb_points;
            if (!points || points.length === 0) return alert('Upload an image first!');
            setTimeout(() => {
                const {centroids, assignments} = kmeans(points, k, 15);

                // Plot clusters and lines (limit lines for performance)
                const traces = [];
                for (let j = 0; j < k; j++) {
                    const clusterIdx = [];
                    for (let i = 0; i < points.length; i++) {
                        if (assignments[i] === j) clusterIdx.push(i);
                    }
                    const xs = clusterIdx.map(i=>points[i][0]);
                    const ys = clusterIdx.map(i=>points[i][1]);
                    const zs = clusterIdx.map(i=>points[i][2]);
                    traces.push({
                        x: xs, y: ys, z: zs,
                        mode: 'markers', type: 'scatter3d',
                        marker: {size:2, color:`rgb(${Math.round(centroids[j][0])},${Math.round(centroids[j][1])},${Math.round(centroids[j][2])})`},
                        name: `Cluster ${j+1}`
                    });
                    // Limit lines to 100 per cluster for performance
                    for (let l = 0; l < Math.min(100, xs.length); l++) {
                        traces.push({
                            x: [centroids[j][0], xs[l]],
                            y: [centroids[j][1], ys[l]],
                            z: [centroids[j][2], zs[l]],
                            mode: 'lines', type: 'scatter3d',
                            line: {color:`rgb(${Math.round(centroids[j][0])},${Math.round(centroids[j][1])},${Math.round(centroids[j][2])})`, width:1},
                            showlegend: false
                        });
                    }
                }
                // Centroid markers
                traces.push({
                    x: centroids.map(c=>c[0]),
                    y: centroids.map(c=>c[1]),
                    z: centroids.map(c=>c[2]),
                    mode: 'markers', type: 'scatter3d',
                    marker: {
                        size: 18,
                        color: centroids.map(_=> '#cccccc'), // light gray
                        symbol: 'star-diamond'
                    },
                    name: 'Centroids'
                });
                const layout = {
                    scene: {
                        xaxis: { title: 'Red', range: [0,255] },
                        yaxis: { title: 'Green', range: [0,255] },
                        zaxis: { title: 'Blue', range: [0,255] }
                    },
                    margin: { l:0, r:0, b:0, t:0 }
                };
                Plotly.newPlot(plotDiv, traces, layout, {responsive:true});

                // Generate new image with centroid colors for ALL pixels
                const width = window._canvasWidth;
                const height = window._canvasHeight;
                const origImgData = window._imgData;
                const imgData = new Uint8ClampedArray(origImgData.length);
                let batchSize = 10000, i = 0, totalPixels = width * height;
                function processBatch() {
                    let end = Math.min(i+batchSize, totalPixels);
                    for (; i < end; i++) {
                        const idx = i * 4;
                        const r = origImgData[idx];
                        const g = origImgData[idx+1];
                        const b = origImgData[idx+2];
                        // Find nearest centroid
                        let minDist = Infinity, minIdx = 0;
                        for (let j = 0; j < centroids.length; j++) {
                            const d = (r-centroids[j][0])**2 + (g-centroids[j][1])**2 + (b-centroids[j][2])**2;
                            if (d < minDist) { minDist = d; minIdx = j; }
                        }
                        const c = centroids[minIdx];
                        imgData[idx] = Math.round(c[0]);
                        imgData[idx+1] = Math.round(c[1]);
                        imgData[idx+2] = Math.round(c[2]);
                        imgData[idx+3] = 255;
                    }
                    if (i < totalPixels) {
                        setTimeout(processBatch, 0);
                    } else {
                        clusteredCanvas.width = width;
                        clusteredCanvas.height = height;
                        const ctx = clusteredCanvas.getContext('2d');
                        const imageData = ctx.createImageData(width, height);
                        imageData.data.set(imgData);
                        ctx.putImageData(imageData, 0, 0);
                        clusteredImage.src = clusteredCanvas.toDataURL();
                        clusteredImage.style.display = 'block';
                        document.getElementById('cluster-label').style.display = 'block';
                    }
                }
                processBatch();
            }, 0);
        });
    </script>
</body>
</html>